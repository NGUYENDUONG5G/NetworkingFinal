####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet

class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.dv = {addr: 0}  # {neighbor_addr, cost} khoảng cách đến đích
        self.forwarding_table = {}   # Lưu lại bảng định tuyến: {dest: (port, cost)}
        self.neighbors = {}  # Danh sách hàng xóm hiện tại: {port: (neighbor_addr, cost)}
        self.dv_from_neighbors = {} # neightborAddr -> { other router :  cost} khoảng cách đến đích



        pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            # Đây là gói tin dữ liệu thông thường (traceroute)
            if packet.dst_addr in self.forwarding_table:
                out_port = self.forwarding_table[packet.dst_addr]
                self.send(out_port, packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            neighbor = packet.src_addr
            new_dv = packet.content

            if (neighbor not in self.dv_from_neighbors) or (self.dv_from_neighbors[neighbor] != new_dv):
                self.dv_from_neighbors[neighbor] = new_dv
                self.update_forwarding_table()
                for p in self.neighbors:
                    if p != port:
                        self.send(p, packet.copy())
            pass
    def send_dv_to_neighbors(self):
        """Gửi DV hiện tại của router này đến tất cả các hàng xóm"""
        for port, (neighbor_addr, _) in self.neighbors.items():
            content = self.dv.copy()
            pkt = Packet(Packet.ROUTING, self.addr, neighbor_addr, content=content)
            self.send(port, pkt)

    def update_forwarding_table(self):
        """Cập nhật bảng định tuyến từ DV và thông tin hàng xóm"""
        updated_dv = {self.addr: 0}
        updated_ft = {}

        for neighbor, their_dv in self.dv_from_neighbors.items():
            if neighbor not in self.neighbors.values():
                continue
            # Tìm port và cost đến hàng xóm
            port = None
            cost_to_neighbor = None
            for p, (n_addr, c) in self.neighbors.items():
                if n_addr == neighbor:
                    port = p
                    cost_to_neighbor = c
                    break
            if port is None:
                continue

            for dest, neighbor_cost in their_dv.items():
                if dest == self.addr:
                    continue  # Bỏ qua chính mình
                total_cost = cost_to_neighbor + neighbor_cost
                if (dest not in updated_dv) or (total_cost < updated_dv[dest]):
                    updated_dv[dest] = total_cost
                    updated_ft[dest] = port

        self.dv = updated_dv
        self.forwarding_table = updated_ft
    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        self.neighbors[port] = (endpoint, cost)
        self.dv_from_neighbors[endpoint] = {}  # chưa có thông tin dv, sẽ nhận sau
        # Cập nhật thông tin về chính mình
        self.dv[self.addr] = 0
        if endpoint not in self.dv or cost < self.dv.get(endpoint, float('inf')):
            self.dv[endpoint] = cost
            self.forwarding_table[endpoint] = port
        self.send_dv_to_neighbors()
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        if port in self.neighbors:
            neighbor_addr, _ = self.neighbors.pop(port)
            if neighbor_addr in self.dv_from_neighbors:
                self.dv_from_neighbors.pop(neighbor_addr)

            # Xóa tất cả route có liên quan
            self.update_forwarding_table()
            self.send_dv_to_neighbors()
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.last_time = time_ms
            self.send_dv_to_neighbors()
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"

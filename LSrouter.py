####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################


from router import Router
import Packet
import heapq


class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        # Bảng lưu trạng thái liên kết của router bất kì: {router_addr: (seq_num, {neighbor: cost, ...})}
        self.lsdb = {}
        # Danh sách hàng xóm hiện tại: {port: (neighbor_addr, cost)}
        self.neighbor = {}
        # Lưu lại bảng định tuyến: {dest: (port, cost)}
        self.forwarding_table = {}
        self.seq_num = 0  # Thứ tự phiên bản riêng của router này

        pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if dst in self.forwarding_table:
                # Nếu biết đường đi, gửi gói đến cổng tương ứng
                out_port = self.forwarding_table[dst][0]
                self.send(out_port, packet)

            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            # địa chỉ đích, số thứ tự phiên bản, các liên kết của router đó
            goalAddr, seq, links = packet.content

            # Kiểm tra nếu LSP này mới hơn
            if (goalAddr not in self.lsdb) or (seq > self.lsdb[goalAddr][0]):
                # Cập nhật cơ sở dữ liệu
                self.lsdb[goalAddr] = (seq, links)

                # Tính lại bảng định tuyến
                self.run_dijkstra()

                # gửi tiếp LSP này đến các hàng xóm khác (trừ nơi nhận)
                for p in self.neighbors:
                    if p != port:
                        self.send(p, packet.copy())
            pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.neighbors[port] = (endpoint, cost)
        self.seq_num += 1
        self.send_lsp_to_neighbors()
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        if port in self.neighbors:
            del self.neighbors[port]
            self.seq_num += 1
            self.send_lsp_to_neighbors()
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.send_lsp_to_neighbors()
            pass
# gửi 1 gói tin đến tất cả hàng xóm, để họ cập nhật thêm thông tin

    def send_lsp_to_neighbors(self):
        # Gói tin LSP gồm: (địa chỉ nguồn, sequence number, {neighbor: cost})
        link_state = {}

        for _, (addr, cost) in self.neighbors.items():
            link_state[addr] = cost

        lsp = Packet(Packet.ROUTING, self.addr, None,
                     content=(self.addr, self.seq_num, link_state))

      # Cập nhật LSDB chính mình
        self.lsdb[self.addr] = (self.seq_num, link_state)

       # Gửi đến tất cả hàng xóm
        for port in self.neighbors:
            self.send(port, lsp.copy())

        # Tính lại bảng định tuyến
        self.run_dijkstra()

    def run_dijkstra(self):
        # Dijkstra từ self.addr dựa trên lsdb
        graph = {}
        for router, (_, neighbors) in self.lsdb.items():
            graph[router] = neighbors

        distTo = {self.addr: 0}
        prev = {}
        port_to = {}

        heap = [(0, self.addr)]
        visited = set()

        while heap:
            cost, u = heapq.heappop(heap)
            if u in visited:
                continue
            visited.add(u)

            if u in graph:
                for v, w in graph[u].items():
                    if v not in distTo or cost + w < distTo[v]:
                        distTo[v] = cost + w
                        prev[v] = u
                        # sửa lại giá trị của router đó trong heap
                        heapq.heappush(heap, (distTo[v], v))

        # Xây bảng định tuyến từ self đến các đích
        self.forwarding_table.clear()
        for dest in distTo:
            if dest == self.addr:
                continue
            # Truy ngược để tìm bước đầu tiên
            next_hop = dest
            while prev.get(next_hop) != self.addr:
                next_hop = prev.get(next_hop)
                if next_hop is None:
                    break
            if next_hop is None:
                continue
            # Tìm cổng đi đến next_hop
            for port, (addr, _) in self.neighbors.items():
                if addr == next_hop:
                    self.forwarding_table[dest] = (port, distTo[dest])

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
